var documenterSearchIndex = {"docs":
[{"location":"#VectorizedRNG.jl","page":"Home","title":"VectorizedRNG.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [VectorizedRNG]","category":"page"},{"location":"#VectorizedRNG.MutableXoshift","page":"Home","title":"VectorizedRNG.MutableXoshift","text":"Oops, I got the name wrong.\n\n\n\n\n\n","category":"type"},{"location":"#VectorizedRNG.Xoshift","page":"Home","title":"VectorizedRNG.Xoshift","text":"Oops, I got the name wrong.\n\n\n\n\n\n","category":"type"},{"location":"#Base.rand-Union{Tuple{V}, Tuple{T}, Tuple{W}, Tuple{VectorizedRNG.AbstractVRNG, Type{V}, T, T}} where {W, T<:Union{Float32, Float64}, V<:VectorizationBase.AbstractSIMD{W, T}}","page":"Home","title":"Base.rand","text":"if l < u, Samples uniformly from [l,u) else, Samples uniformly from (u,l]\n\nThat is, the \"l\" side of the interval is closed, and the \"u\" side is open.\n\n\n\n\n\n","category":"method"},{"location":"#Base.rand-Union{Tuple{W}, Tuple{VectorizedRNG.AbstractVRNG, Type{VectorizationBase.Vec{W, Float64}}}} where W","page":"Home","title":"Base.rand","text":"Samples uniformly from (0.0,1.0)\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedRNG.floatbitmask-Tuple{Any, Type{Float64}}","page":"Home","title":"VectorizedRNG.floatbitmask","text":"The masks mask off bits so that a set of bits will be within the range 1.0 and prevfloat(2.0). They do this via first using the bitwise-and to set all the exponent bits and the sign-bit to 0, and then using the bitwise-or to set all but the first exponent bit to 1. Neither operation touches the fraction-bits.\n\nFor example, you can see the binary representation of a double precision number on wikipedia: https://en.wikipedia.org/wiki/Double-precisionfloating-pointformat and then julia> bitstring(0x000fffffffffffff) \"0000000000001111111111111111111111111111111111111111111111111111\"\n\njulia> bitstring(0x3ff0000000000000) \"0011111111110000000000000000000000000000000000000000000000000000\"\n\nso that (x & 0x000fffffffffffff) | 0x3ff0000000000000 has the desired effect of setting the sign bit to 0, and the exponent bit to be within the proper range. Note that the second string has 10 \"1\"s, so that it is 2^10. For double precision, the exponential contribution is 2^(e - 1023). With e = 2^10, we have 2^(2^10 - 1023) = 2^(1024 - 1023) = 2^1 = 2. Thus, the fraction specifies where in the range between 1.0 and prevfloat(2.0). If the fraction bits are completely random, the distribution will be uniform between 1.0 and prevfloat(2.0).\n\nThe reason we target that range (1.0 to prevfloat(2.0)) is to get a nice, uniform distribution. We can get uniform(0, 1] via 2 - u, or a uniform[0,1) via u - 1. Choosing other fractional intervals, eg [0.5, 1.0) or [2.0, 4.0) would take more work to translate. Alternatively, if we tried to span multiple fractional intervals, suddenly trying to get a fairly uniform distribution would get complicated.\n\n\n\n\n\n","category":"method"},{"location":"#VectorizedRNG.setbits-Tuple{Any, Any, Any}","page":"Home","title":"VectorizedRNG.setbits","text":"setbits(x::Unsigned, y::Unsigned, mask::Unsigned)\n\nIf you have AVX512, setbits of vector-arguments will select bits according to mask m, selecting from y if 0 and from x if 1. For scalar arguments, or vector arguments without AVX512, setbits requires the additional restrictions on y that all bits for which m is 1, y must be 0. That is for scalar arguments or vector arguments without AVX512, it requires the restriction that ((y ‚äª m) & m) == m\n\n\n\n\n\n","category":"method"}]
}
